<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Markdown Globbing</title>
    <link rel="stylesheet" href="assets/assemble.css">
    <link rel="stylesheet" href="assets/github.css">
  </head>
  <body style="background: white;">


    <!-- Navbar 
    ============================================== -->
    
<!-- Navbar component
================================================== -->
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="navbar-brand" href="../dest/index.html">ASSEMBLE</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <div class="nav-collapse collapse bs-navbar-collapse">
        <ul class="nav navbar-nav">
          <li>
            <a href="../dest/examples.html">Examples</a>
          </li>
        </ul>
        <ul class="nav navbar-nav pull-right">
          <li> <a href="https://github.com/assemble/assemble/">Assemble Docs</a> </li>
          <li> <a href="https://github.com/assemble/boilerplate-markdown/">GitHub Repo</a> </li>
        </ul>
      </div>
    </div>
  </div>
</div>


    <!-- Subhead
    ============================================== -->
    <header class="masthead subhead">
      <div class="container">
        <div class="row">
          <div class="col col-lg-12">
            <h1><span class="text-muted">Docs /</span> Markdown Helpers </h1>
          </div>
        </div>
      </div>
    </header>


    <!-- Page content
    ============================================== -->
    <div class="container">
      <div class="col col-lg-3">
        <div class="sidebar">
  <span class="nav-section-title">
    <strong>{{markdown}}</strong> Helper
  </span>
  <ul class="nav nav-pills nav-stacked">
    <li><a href="markdown-block-1.html">Inline Markdown</a></li>
    <li><a href="markdown-block-2.html">Markdown "Includes"</a></li>
  </ul>
  <span class="nav-section-title">
    <strong>{{md}}</strong> Helper
  </span>
  <ul class="nav nav-pills nav-stacked">
    <li><a href="markdown-globbing-1.html">Alternate "Includes"</a></li>
    <li><a href="markdown-globbing-1.html">File Globbing #1</a></li>
    <li><a href="markdown-globbing-2.html">File Globbing #2</a></li>
  </ul>
</div>

      </div>
      
      <div class="col col-lg-9 panel-docs">
        

<h1>Options</h1>
<blockquote>
<p>Comprehensive list of options available in Assemble</p>
</blockquote>
<p>Most options are defined in the <code>assemble</code> task or target options in the Gruntfile, some options may only be defined inside the [YAML front matter][yaml-front-matter] of a file, and some may be defined in either location. </p>
<p>Additionally, options may be defined in &quot;external&quot; [JSON][] or [YAML][] configuration files.</p>
<p>For the purposes of clarity, we will refer to options that are defined in the Gruntfile as &quot;configuration&quot; options, and options that are defined in the YFM as &quot;page&quot; options.</p>
<h2 id="configuration-options">Configuration options</h2>
<p>These options are defined in the <code>assemble</code> task in your project&#39;s Gruntfile. Any option may be defined at the <a href="http://gruntjs.com/configuring-tasks#task-configuration-and-targets">task or target</a> level.</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[assets][options-assets]</td>
<td>directory that contains commonly used &quot;assets&quot; for a project, such as images, fonts, javascripts and stylesheets. Assemble will generate a relative path  from dest files to the given <code>assets</code> directory.</td>
</tr>
<tr>
<td>[collections][options-collections]</td>
<td></td>
</tr>
<tr>
<td>[data][options-data]</td>
<td>path to data files to supply the data that will be passed into templates.</td>
</tr>
<tr>
<td>[engine][options-engine]</td>
<td>engine to be used for processing templates. Handlebars is the default.</td>
</tr>
<tr>
<td>[ext][options-ext]</td>
<td>extension to be used for <code>dest</code> files.</td>
</tr>
<tr>
<td>[helpers][options-helpers]</td>
<td>path to custom helper(s) to be registered and used by the current template engine. Handlebars is the default.</td>
</tr>
<tr>
<td>[layout][options-layout]<strong> * </strong></td>
<td>[Layouts][] are optional and assemble will build [pages][] without one. However, when a layout is specified the file <em>must contain a <code>{{&gt; body }}</code></em> tag,  since this tag indicates where the content from each file in a target should be inserted.</td>
</tr>
<tr>
<td>[layoutdir][options-layoutdir]<strong> * </strong></td>
<td>[Layouts][] are optional and assemble will build [pages][] without one. However, when a layout is specified the file <em>must contain a <code>{{&gt; body }}</code></em> tag,  since this tag indicates where the content from each file in a target should be inserted.</td>
</tr>
<tr>
<td>[partials][options-partials]</td>
<td>the partials or &quot;includes&quot; to be used with [pages][].</td>
</tr>
</tbody>
</table>
<p><strong>*Note</strong> that when a layout is used the [{{&gt; body }}][Layouts] tag must be included inside the layout in order for content from pages to be &quot;pulled in&quot;. </p>
<h2 id="task-options">Task Options</h2>
<p>These options are defined in the <code>assemble</code> task in your Gruntfile.</p>
<h3 id="-options-data-options-data-">[options.data][options-data]</h3>
<p>Type: <code>String|Array</code> (optional)
Default: <code>src/data</code></p>
<p>Retrieves data from any specified <code>JSON</code> and/or <code>YAML</code> files to populate the templates when rendered. Data gets passed through the <code>data</code> object to the options on the assemble task, and then to the context in your templates. Also useful for specifying [configuration][] data.</p>
<pre><code class="language-js">options: { data: <span class="string">'src/data/**/*.{json,yml}'</span> }</code></pre>
<p>Note that <code>assemble</code> merges the task and target-level data for <code>options.data</code>.</p>
<h3 id="-options-layout-options-layout-">[options.layout][options-layout]</h3>
<p>Type: <code>String</code> (optional)
Default: <code>undefined</code></p>
<p>Layouts are optional and may be defined at the task and/or <a href="http://gruntjs.com/configuring-tasks#task-configuration-and-targets">target</a> level. <em>Unlike Jekyll</em>, Assemble requires a file extension since you are not limited to using a single file type.</p>
<pre><code class="language-js">options: { layout: <span class="string">'src/layouts/default.hbs'</span> }</code></pre>
<h3 id="-options-assets-options-assets-">[options.assets][options-assets]</h3>
<p>Type: <code>String</code> (optional)
Default: <code>undefined</code></p>
<p>Path to the &quot;assets&quot; or &quot;public&quot; directory that will be used by dest files. Assemble uses path in the <code>assets</code> option to generate a relative path from dest files to the given &quot;assets&quot; directory. The &quot;assets&quot; folder commonly contains the CSS, JavaScripts, images and other similar files for a project. The <code>assets</code> option may be defined at the task or target-level.</p>
<pre><code class="language-js">options: { assets: <span class="string">'docs/assets'</span> }</code></pre>
<h3 id="-options-partials-options-partials-">[options.partials][options-partials]</h3>
<p>Type:  <code>String|Array</code> (optional)
Default: <code>undefined</code></p>
<p>Specifies the Handlebars partials files, or paths to the directories of files to be used. </p>
<pre><code class="language-js">options: { partials: <span class="string">'src/partials/**/*.hbs'</span> }</code></pre>
<p>Note that <code>assemble</code> merges the task and target-level data for <code>options.partials</code>.</p>
<h3 id="-options-ext-options-ext-">[options.ext][options-ext]</h3>
<p>Type: <code>String</code> (optional)
Default: <code>.html</code></p>
<p>Specify the file extension to be used for destination files. For example:</p>
<pre><code class="language-js">assemble: {
  <span class="comment">// Build sitemap from JSON and templates</span>
  sitemap: {
    options: { ext: <span class="string">'.xml'</span>},
    files: {
      <span class="string">'.'</span>: [<span class="string">'path/to/sitemap.tmpl'</span>]
    }
  },
  <span class="comment">// Build README from YAML and templates</span>
  readme: {
    options: { ext: <span class="string">'.md'</span> },
    files: {
      <span class="string">'.'</span>: [<span class="string">'path/to/readme.tmpl'</span>]
    }
  }
}</code></pre>
<p>Learn more about the [ext option][options-ext].</p>
<h3 id="-options-engine-options-engine-">[options.engine][options-engine]</h3>
<p>Type: <code>String</code> (optional)
Default: <code>handlebars</code></p>
<p>The engine to use for processing client-side templates. Assemble ships Handlebars as the default template engine, to learn more about adding other template engines please read the documentation on [assemble methods][methods].</p>
<p>Also, we welcome pull requests for additional template engines. If you have questions please create an [Issue][assemble-issues].</p>
<h3 id="-options-helpers-options-helpers-">[options.helpers][options-helpers]</h3>
<p>Type: <code>String|Array</code> (optional)
Default: 100+ helpers from [helper-lib][] </p>
<p>Assemble depends on [helper-lib][], an external library which includes more than <strong>100 Handlebars helpers</strong>. So any helpers from that project may be used in your templates. </p>
<p>If you wish for Assemble to use custom helpers with Handlebars or any specified template engine, just provide the path to the helper or helpers in <code>options.helpers</code> :  </p>
<pre><code class="language-js">options: { helpers: <span class="string">'your/custom/helpers'</span> }</code></pre>
<h3 id="options-removehbswhitespace">options.removeHbsWhitespace</h3>
<p>Type: <code>Boolean</code>
Default: <code>false</code></p>
<p>Remove extraneous whitespace added by Handlebars in rendered files. <em>Use at your own risk, this is an experimental option and may be removed.</em></p>
<h2 id="-yaml-front-matter-options-yaml-front-matter-">[YAML Front-Matter Options][yaml-front-matter]</h2>
<p>These options are defined in the [YAML front matter][yaml-front-matter] of a page.</p>
<h3 id="-options-layout-options-layout-">[options.layout][options-layout]</h3>
<p>type: <code>string</code>
default: <code>undefined</code></p>
<p>Specifies the [layout][Layouts] file to be used. Layouts defined in [YFM][yaml-front-matter] will override layouts defined in the Gruntfile.</p>
<h3 id="options-published">options.published</h3>
<p>type: <code>boolean</code>
default: true</p>
<p>Defining <code>published: false</code> in the [YAML front matter][yaml-front-matter] of a page will:</p>
<ul>
<li>Prevent the page from rendering</li>
<li>Omit the page from the <code>pages</code> collection. </li>
</ul>
<h2 id="custom-options">Custom Options</h2>
<p>Custom, user-defined variables may be specified in the [Options][options-overview] of the assemble task or target. Any variables defined in the options will be added to the <em>root of the data context</em> and thus they will also be available in any templates. </p>
<h3 id="example-usage">Example usage</h3>
<p>A common use case for defining custom variables in the options is for easily including or excluding content based on current &quot;development status&quot;. </p>
<p>For example, assuming we have defined a custom option, <code>production</code>:</p>
<pre><code class="language-js">assemble: {
  options: {
    production: <span class="literal">false</span>
  },
  files: {
    <span class="string">'site/'</span>: [<span class="string">'src/pages/*.hbs'</span>]
  }
}</code></pre>
<p>And we add the <code>production</code> variable to our templates:</p>
<pre><code class="language-html">{{#if production}}
  &lt;script src=&quot;dist/assets/script.min.js&quot;&gt;&lt;/script&gt;
{{else}}
  &lt;script src=&quot;dist/assets/script.js&quot;&gt;&lt;/script&gt;
{{/if}}</code></pre>
<p>Since <code>production: false</code> is defined in the Assemble [task options][options], the following HTML will be rendered with the <em>non-minified</em> version of the script:</p>
<pre><code class="language-html">&lt;script src=&quot;dist/assets/script.js&quot;&gt;&lt;/script&gt;</code></pre>
<h2 id="-grunt-js-tasks-and-targets-options"><a href="http://gruntjs.com/configuring-tasks#task-configuration-and-targets">Grunt.js</a> Options</h2>
<p>The following is just a handful of options that can be used in your Gruntfile. Please visit the <a href="http://gruntjs.com/api/grunt.file">Grunt documentation</a> to learn more.</p>
<ul>
<li><code>expand</code> Set to <code>true</code> to enable the following options:</li>
<li><code>cwd</code> All <code>src</code> matches are relative to (but don&#39;t include) this path.</li>
<li><code>src</code> Pattern(s) to match, relative to the <code>cwd</code>.</li>
<li><code>dest</code> Destination path prefix.</li>
<li><code>ext</code> Replace any existing extension with this value in generated <code>dest</code> paths.</li>
<li><code>flatten</code> Remove all path parts from generated <code>dest</code> paths.</li>
<li><code>rename</code> This function is called for each matched <code>src</code> file, (after extension renaming and flattening). The <code>dest</code> and matched <code>src</code> path are passed in, and this function must return a new <code>dest</code> value.  If the same <code>dest</code> is returned more than once, each <code>src</code> which used it will be added to an array of sources for it.</li>
</ul>
<h2 id="related-info-">Related info:</h2>
<ul>
<li><p>[Variables][built-in-variables]</p>
</li>
<li><p>[YAML Options][YAML]</p>
</li>
</ul>

<h2 id="options-assets">options.assets</h2>
<blockquote>
<p>&quot;Assets&quot; directory to be used by dest files in a target.</p>
</blockquote>
<p>Type: <code>String</code> (optional)
Default: <code>undefined</code></p>
<p><em><code>options.assets</code> may be defined at the task- and/or target-levels.</em></p>
<h2 id="overview">Overview</h2>
<p>Oftentimes an &quot;assets&quot; directory is used in projects for containing the CSS, JavaScripts, images and other similar files. </p>
<p>Once the <code>assets</code> variable is defined in the Gruntfile, you may use the <code>{{assets}}</code> variable anywhere in your templates and Assemble will generate a relative path from <code>dest</code> files to the specified <code>assets</code> directory. </p>
<h2 id="example-usage">Example usage</h2>
<p>Given the following task configuration in your project&#39;s Grunfile:</p>
<pre><code class="language-js">assemble: {
  options: { 
    <span class="comment">// Set the "default" assets dir at the task-level</span>
    assets: <span class="string">'docs/assets'</span> 
  },
  docs: {
    files: {
      <span class="string">'docs/'</span>: [<span class="string">'src/pages/**/*.hbs'</span>]
    }
  },
  components: {
    files: {
      <span class="string">'docs/components/'</span>: [<span class="string">'src/partials/**/*.hbs'</span>]
    }
  },
  main: {
    options: { 
      <span class="comment">// Override the task-level assets dir</span>
      assets: <span class="string">'dist/assets'</span> 
    },
    files: {
      <span class="string">'dist/'</span>: [<span class="string">'src/pages/**/*.hbs'</span>]
    }
  }
  <span class="comment">// other stuff</span>
}</code></pre>
<p>And given the following templates: </p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;{{assets}}/css/bootstrap.css&quot;&gt;</code></pre>
<p>The output HTML will render as follows:</p>
<p>For the <code>assemble.docs</code> target</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/bootstrap.css&quot;&gt;</code></pre>
<p>For the <code>assemble.components</code> target</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;../assets/css/bootstrap.css&quot;&gt;</code></pre>
<p>For the <code>assemble.main</code> target</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/bootstrap.css&quot;&gt;</code></pre>
<p><strong>Note</strong> that for <code>assets</code> to work predictably, <em>a slash must follow the `{{assets}} variable</em></p>
<h2 id="more-information">More information</h2>
<ul>
<li>[Options][]</li>
<li>[variables][built-in-variables]</li>
</ul>
<h2 id="default-collections">Default Collections</h2>
<p>The following built-in collections are available at the root of the context:</p>
<table>
<thead>
<tr>
<th><strong>Collection</strong></th>
<th><strong>Collection item</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tags</code></td>
<td><code>tag</code></td>
<td>Used to specify tags associated with the current page. Multiple tags may be associated with each page. Useful for adding semantic <strong>tags</strong> or tag clouds to your content.</td>
</tr>
<tr>
<td><code>categories</code></td>
<td><code>category</code></td>
<td>Used to specify categories associated with the current page. Multiple categories may be associated with each page. Similar to tags but more appropriate for categorizing pages by &quot;broader&quot; concepts.</td>
</tr>
<tr>
<td><code>pages</code></td>
<td><code>page</code></td>
<td>See <strong>Pages collection differences</strong> below</td>
</tr>
</tbody>
</table>
<h3 id="pages-collection-differences">Pages collection differences</h3>
<p>&quot;[Pages][]&quot; and &quot;page&quot; differ from other collections and collection items in the following ways:</p>
<ul>
<li><em>Any files specified in the <code>src</code> of a given target</em> will be the collection items associated with the &quot;pages&quot; object for that target.</li>
<li>Although a &quot;page&quot; is a collection item, there is currently no concept of &quot;pages with related pages&quot;. In other words <em>there is no object which contains a collection of pages associated with a given page</em>. So </li>
</ul>
<h3 id="collection-items">Collection items</h3>
<p>You may then add items to collections in the YAML front matter of any files that should include those collections:</p>
<pre><code class="language-yaml">---
title: My Blog
archives:
  - 2013
  - May
  - 12
---</code></pre>
<h3 id="list-of-associate-pages">List of associate pages</h3>
<p>Additionally, any collection item from the <code>collections</code> object can list the [pages][pages] associated with that collection. For example, each &quot;tag&quot; would list the [pages][pages] associated with that tag. </p>
<pre><code class="language-javascript">{ 
  tag: <span class="string">'news'</span>, 
  pages: [<span class="string">'one.html'</span>, <span class="string">'two.html'</span>, <span class="string">'three.html'</span>] 
}</code></pre>
<h2 id="custom-collections">Custom collections</h2>
<h3 id="options-collections">options.collections</h3>
<p>type: <code>Array</code>
default: <code>null</code></p>
<p>Custom <code>collections</code> may be defined using the <code>collections</code> option:</p>
<pre><code class="language-javascript">assemble: {
  options: {
    collections: [<span class="string">'archives'</span>, <span class="string">'posts'</span>]
  }
}</code></pre>
<p>And then in the YAML front matter of a page:</p>
<pre><code class="language-yaml">---
archives:
  - 2013
  - May
  - 12
---</code></pre>
<p>There are no restrictions on the number of collections creatd, you may specify as many custom collections as you require. </p>
<h3 id="automatic-inflection">Automatic inflection</h3>
<p>Currently, for the sake of ease of use, the collection method uses the <a href="https://github.com/dreamerslab/node.inflection">inflection</a> library to convert a collection&#39;s item key into the correct syntax:</p>
<ul>
<li><code>tags</code> converts to: <code>{ tag: &#39;ficus&#39;, pages: [] }</code></li>
<li><code>categories</code> converts to: <code>{ category: &#39;trees&#39;, pages: [] }</code></li>
</ul>
<p>If words you wish to use are either missing or don&#39;t work properly, please let us know by <a href="https://github.com/assemble/assemble/issues/">creating an Issue</a> on Assemble&#39;s GitHub repository.</p>
<h2 id="usage-examples">Usage examples</h2>
<p>Declaring tags and categories for a page within the page&#39;s [YAML front matter][yaml-front-matter]</p>
<pre><code class="language-yaml">---
tags:
- feature
- priority
categories:
- open
---</code></pre>
<p><strong>List all tags</strong></p>
<pre><code class="language-html">&lt;ul&gt;
  {{#tags}}
  &lt;li&gt;&lt;a href=&quot;/tag/{{tag}}.html&quot;&gt;{{tag}}&lt;/a&gt;&lt;/li&gt;
  {{/tags}}
&lt;/ul&gt;</code></pre>
<p><strong>List all categories</strong></p>
<pre><code class="language-html">&lt;ul&gt;
  {{#categories}}
  &lt;li&gt;&lt;a href=&quot;/category/{{category}}.html&quot;&gt;{{category}}&lt;/a&gt;&lt;/li&gt;
  {{/categories}}
&lt;/ul&gt;</code></pre>
<p><strong>List tags on current page</strong></p>
<pre><code class="language-html">&lt;ul&gt;
  {{#page.tags}}
  &lt;li&gt;{{.}}&lt;/li&gt;
  {{/page.tags}}
&lt;/ul&gt;</code></pre>
<p><strong>List categories on current page</strong></p>
<pre><code class="language-html">&lt;ul&gt;
  {{#page.categories}}
  &lt;li&gt;{{.}}&lt;/li&gt;
  {{/page.categories}}
&lt;/ul&gt;</code></pre>
<p>Also see the wiki page for [data types][data].</p>
<h2 id="supplying-data-to-templates">Supplying data to templates</h2>
<p>You must first define the paths to any data files you wish to use via the <code>options.data</code> object in the <code>assemble</code> task or target, then Assemble will automatically supply data to your templates:</p>
<pre><code>assemble: {
  options: {
    data: &#39;src/data/*.json&#39;
  }
  files: {
    &#39;site/&#39;: [&#39;src/pages/*.hbs&#39;]
  }
}</code></pre>
<h3 id="matching-names">Matching names</h3>
<p>Context to  the name of the data file is the same as the associated template, and we   </p>
<p>To use &quot;external&quot; data files (versus YAML front matter), y</p>
<p><strong>&quot;widget component&quot; example</strong></p>
<p>Given a data file, such as <code>widget.json</code> or <code>widget.yml</code> :</p>
<pre><code class="language-json">{
  "<span class="attribute">name</span>": <span class="value"><span class="string">"This is a square widget"</span></span>,
  "<span class="attribute">modifier</span>": <span class="value"><span class="string">"widget-square"</span>
</span>}</code></pre>
<p>With the following Handlebars expressions in out template, <code>widget.hbs</code> :</p>
<pre><code class="language-html">&lt;div class=&quot;widget {{ widget.modifier }}&quot;&gt;{{ widget.name }}&lt;/div&gt;</code></pre>
<p>The result after running <code>grunt assemble</code> will be:</p>
<pre><code class="language-html">&lt;div class=&quot;widget widget-square&quot;&gt;This is a square widget&lt;/div&gt;</code></pre>
<p><strong>package.json example #1</strong></p>
<p>Add <code>package.json</code> to the <code>data</code> object:</p>
<pre><code class="language-javascript">assemble {
  myProject: {
    options: {
      data: <span class="string">'package.json'</span>
    },
    files: {
      <span class="string">'dest'</span>: [<span class="string">'src/templates/**/*.hbs'</span>]
    }
  }
}</code></pre>
<p>And we will not be able to retrieve metadata from <code>package.json</code> by using variables such as:</p>
<ul>
<li><code>{{package.verson}}</code></li>
<li><code>{{package.name}}</code></li>
<li><code>{{package.description}}</code></li>
<li><code>{{package.author.url}}</code></li>
<li><code>{{package.author.name}}</code></li>
</ul>
<p><strong>package.json example #2</strong></p>
<p>Assuming we add the following code to our Gruntfile</p>
<pre><code class="language-javascript">pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),

assemble {
  myProject: {
    options: {
      pkg: <span class="string">'&lt;%= pkg %&gt;'</span>,
      data: <span class="string">'other/data/*.json'</span>
    },
    files: {
      <span class="string">'dest'</span>: [<span class="string">'src/templates/**/*.hbs'</span>]
    }
  }
}</code></pre>
<p>We can now use the following expresions in our templates:</p>
<ul>
<li><code>{{pkg.verson}}</code></li>
<li><code>{{pkg.name}}</code></li>
<li><code>{{pkg.description}}</code></li>
<li><code>{{pkg.author.url}}</code></li>
<li><code>{{pkg.author.name}}</code></li>
</ul>
<p>Also see: [YAML front matter][yaml-front-matter]</p>
<h2 id="related-info">Related Info</h2>
<ul>
<li>[Complete list of Options][Options]</li>
<li>[Data Types][data]</li>
<li>[variables][built-in-variables]</li>
</ul>
<h2 id="-init-method"><code>init</code> method</h2>
<p>Describes <code>init</code> method to <code>assemble.engine</code>, and exposes engine on <code>assemble.engine</code>.</p>
<h3 id="custom-engines">Custom Engines</h3>
<p>If you don&#39;t wish to use Handlebars as your templates engine, you may add your own engine by providing an <code>init</code> function that takes in options from the assemble task/target. You may also override the <code>init</code> function in the task/target options by providing an <code>initializeEngine</code> function that takes the engine and the options:</p>
<pre><code class="language-js">assemble: {
  options: {
    engine: <span class="string">'consolidate'</span>,
    initializeEngine: <span class="function"><span class="keyword">function</span><span class="params">(engine, options)</span> {</span>
      engine.engine.swig.init(options);
    }
  },
  docs: {
    files: {
      <span class="string">'docs/'</span>: [<span class="string">'src/templates/**/*.tmpl'</span>]
    }
  }
}</code></pre>
<p>Assemble will attempt to load an engine and automatically add it&#39;s own wrapper methods around it while holding an instance of the engine. This is a way for engine plugin authors to write adapters between other engines and assemble&#39;s wrapper. To make these functions on the options useful, we&#39;ve exposed the underlying engine through the <code>assemble.engine</code> object so <strong>developers can use the raw engine</strong>. </p>
<p>This is particularly useful when <strong>a)</strong> a library such as [consolidate][] is used, where the engine is <code>consolidate</code>, and <strong>b)</strong> the developer wants to use another engine such as <a href="https://github.com/wycats/handlebars.js">handlebars</a>, <a href="https://github.com/paularmstrong/swig">swig</a>, <a href="https://github.com/janl/mustache.js">mustache</a> etc.</p>
<ul>
<li>The <code>init</code> function allows assemble to pass in options to be used in initializing this engine plugin.</li>
<li><code>init</code> function is exposed, and <a href="https://github.com/assemble/helper-lib">helper-lib</a> is registered inside the init so that options can be passed in.</li>
</ul>
<p>Admittedly, the <code>engine.engine</code> syntax is strange. This is &quot;alpha&quot;, so feedback and pull requests are especially welcome if you have ideas for improving this.</p>
<h2 id="options-ext">options.ext</h2>
<blockquote>
<p>Specify the file extension to use on dest files. Extensions can be specified at the task and target-levels.</p>
</blockquote>
<p>Type: <code>String</code> (optional)
Default: <code>.html</code></p>
<h2 id="overview">Overview</h2>
<p>When planning out the strategy for your build targets, [templates][templates] and [data][data], don&#39;t forget to take the <code>ext</code> variable into consideration. <code>ext</code> opens up a few doors by &quot;bending the rules&quot; around how your source files will be compiled or rendered.  </p>
<p>In 90% of cases, the <code>ext</code> option will not be needed, and simply using the <code>.hbs</code> file extension on your [templates][templates] will suffice. However, in scenarios where you are using mixed content, say HTML and markdown with Handelbars templates embedded in one or both formats, you may need to use the <code>ext</code> option to esure that you get the output you need. </p>
<h3 id="mixed-content-markdown-and-html-together">Mixed content: Markdown and HTML together</h3>
<p>Consider the following scenario:</p>
<ul>
<li>Your page content and/or blog posts will be written in [markdown][markdown] format</li>
<li>You want to embed Handlebars templates in your markdown content for certain types of metadata, such as links, date/time, etc.</li>
<li>Your page [layouts][layouts] are made from HTML, but they also with embedded with Handlebars templates</li>
<li><p>Your end goal is for all of your markdown content to be rendered to HTML in the output.</p>
<p>and you want your need to compile some markdown files to HTML, and you want to use other markdown files as &quot;includes&quot; or &quot;partials&quot; inside other markdown files, in which case you want the markdown files to be rendered <em>as markdown</em> in the output. You may even want to embed Handlebars templates inside your markdown files to be parsed and compiled. </p>
</li>
</ul>
<h2 id="extensions-map">Extensions map</h2>
<h3 id="whitelisted-extensions">Whitelisted extensions</h3>
<p>As of NaN/NaN/NaN NaN:NaNAM, Assemble&#39;s extensions map &quot;whitelists&quot; the following extensions:</p>
<p><strong>Handlebars extensions</strong></p>
<ul>
<li><code>handlebar : handlebars</code></li>
<li><code>handlebars: handlebars</code></li>
<li><code>hb        : handlebars</code></li>
<li><code>hbars     : handlebars</code></li>
<li><code>hbrs      : handlebars</code></li>
<li><code>hbs       : handlebars</code></li>
<li><code>hbt       : handlebars</code></li>
<li><code>htm       : handlebars</code></li>
<li><code>html      : handlebars</code></li>
<li><code>mustache  : handlebars</code></li>
<li><code>template  : handlebars</code></li>
<li><code>tmpl      : handlebars</code></li>
<li><code>tpl       : handlebars</code></li>
</ul>
<p><strong>Markdown extensions</strong></p>
<ul>
<li><code>markd   : markdown</code></li>
<li><code>markdown: markdown</code></li>
<li><code>md      : markdown</code></li>
</ul>
<h3 id="forcing-non-whitelisted-extensions">Forcing non-whitelisted extensions</h3>
<p>If you need Assemble to process templates in files with an extension that isn&#39;t in <a href="https://github.com/assemble/assemble/blob/master/lib/engine/extensions.yml">extensions.yml</a>, you must <em>explicitly define the template engine in the task/target options to force Assemble to process your templates.</em></p>
<p>So given this example:</p>
<pre><code class="language-js">assemble: {
  options: {
    engine: <span class="string">"Handlebars"</span> <span class="comment">// case insensitive</span>
  },
  files: {
    <span class="string">'dist/'</span>: [<span class="string">'src/pages/*.snickerdoodle'</span>]
  }
}</code></pre>
<p>So now that we have defined an engine, Handlebars, Assemble knows to use that engine to process templates with the <code>.snickerdoodle</code> extension. Even better, your templates will also be compiled into delicious Christmas cookies with cinnamon and sugar sprinkled on top. </p>
<h2 id="example-usage">Example usage</h2>
<p>Here are some examples that cover common use cases.</p>
<h3 id="markdown-to-markdown">Markdown-to-markdown</h3>
<p>If your repo is on GitHub, it&#39;s a safe bet you&#39;re using markdown format on your READMEs and wikis. Here we&#39;re going to show you how to use templates to generate markdown files, so if you work on big projects, or a lot of projects, you can potentially reduce the amount of time you spend updating documentation, changelogs, links, common metadata and so on. </p>
<p>Now, of course there are many ways to accomplish the same goal, this is an example so we&#39;re going for simplicity. Here&#39;s what we want to accomplish:</p>
<ul>
<li><code>src</code> content <em>written</em> in markdown</li>
<li><code>src</code> content contains templates, </li>
<li>Metadata for templates must come from a single source, say <code>package.json</code> (this is arbitrary, you can use more than one  file if you want, <code>.yml</code> format is fine too)</li>
<li>generated <code>dest</code> files must remain in markdown format. In other words, we want Assemble to process the templates, but not to convert the markdown to HTML. </li>
</ul>
<p>Here is what we need to do:</p>
<p>Example configuration:</p>
<pre><code class="language-js">assemble: {
  options: {
    data: <span class="string">'src/data/readme.yml'</span>,
    partials: <span class="string">'src/content/*.hbs'</span>,
    ext: <span class="string">''</span> <span class="comment">// add the "empty" ext property</span>
  },
  readme: {
    files: {
      <span class="string">'./'</span>: [<span class="string">'src/templates/README.md.hbs'</span>]
    }
  }
}</code></pre>
<p>Our goal here is to tell the <code>assemble</code> task to treat the <code>src</code> markdown files as regular content. In other words we don&#39;t want the task to convert the markdown files to HTML, so we use a sort of trick that allows us to write our README content in markdown along with embedded Handlebars templates. </p>
<p>Our goal here is to tell the <code>assemble</code> task.</p>
<p>Here, we tell the <code>assemble</code> task not to use an extension on <code>dest</code> files by leaving <code>ext: &#39;&#39;</code> blank. We do this because our templates have the extenions <code>.md.hbs</code> and assemble only slices off the last extension at build time. So by 1) telling assemble not to add another extension to the rendered templates, and 2) by naming our template files with the <code>.md.hbs</code> extension, we </p>
<h3 id="markdown-to-html">markdown-to-HTML</h3>
<p>Common use cases:</p>
<ul>
<li>Blog posts written in markdown, converted to HTML for a live site.</li>
<li>gh-pages documentation</li>
</ul>
<pre><code class="language-js">assemble: {
  options: {
    engine: <span class="string">"Handlebars"</span> <span class="comment">// case insensitive</span>
  },
  files: {
    <span class="string">'dist/'</span>: [<span class="string">'src/pages/*.md.hbs'</span>]
  }
}</code></pre>
<p>Rendered pages will have the <code>.html</code> extension by default.</p>
<h2 id="options-helpers">options.helpers</h2>
<blockquote>
<p>Helpers manipulate the output of variables</p>
</blockquote>
<p>For the most part helper expressions follow this pattern: <code>{{ helper_name variable_name }}</code>. For example:</p>
<pre><code>&lt;title&gt;{{ uppercase title }}&lt;/title&gt;</code></pre>
<p>Renders to:</p>
<pre><code>&lt;title&gt;PAGE TITLE&lt;/title&gt;</code></pre>
<h2 id="custom-helpers">Custom helpers</h2>
<p>Custom helpers may be loaded with the current engine via <code>options: { helpers: []}</code> in the assemble task or target. But <em>any helpers registered at the target level will override task-level helpers</em>.</p>
<p>Globbing patterns may be used to specify paths to the helpers to be loaded:</p>
<pre><code class="language-js">assemble: {
  options: {
    helpers: [<span class="string">'./lib/helpers/**/*.js'</span>]
  }
}</code></pre>
<h3 id="registering-custom-helpers">Registering custom helpers</h3>
<p>Helpers can either be an object or a single <code>register</code> function. If <code>register</code> is on the object, then it calls the <code>register</code> function passing in the engine, otherwise each method is registered as a helper. For example, the following will result in 2 helpers being registered:</p>
<pre><code class="language-js">module.exports.foo = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span> <span class="keyword">return</span> msg; };
module.exports.bar = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span> <span class="keyword">return</span> msg; };</code></pre>
<p>And this will result in the <code>foo</code> helper getting register directly through Handlebars:</p>
<pre><code class="language-js">module.exports.register = <span class="function"><span class="keyword">function</span><span class="params">(Handlebars, options)</span> {</span>
  Handlebars.registerHelper(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
    <span class="keyword">return</span> msg;
  });
};</code></pre>
<p>The <code>Handlebars.registerHelper</code> method takes the name of the helper and the helper function as arguments. Handlebars.js then takes whatever is returned from the helper function and writes it out to the template, <em>so be sure to always return a string from your custom helpers</em>.</p>
<h2 id="passing-assemble-options-into-helpers">Passing <code>assemble.options</code> into helpers</h2>
<p>Any <code>assemble.options</code> may be passed to custom helpers when the helper defines the <code>register</code> method. For example:</p>
<p>Given our <code>Gruntfile.js</code> has the following <code>assemble</code> task configuration:</p>
<pre><code class="language-js">assemble: {
  options: {
    version: <span class="string">'0.1.0'</span>, <span class="comment">// or we could use '&lt;%= pkg.version %&gt;'</span>
    helpers: [<span class="string">'lib/helpers/**/*.js'</span>]
  },
  blog: {
    files: {
      <span class="string">'articles/'</span>: [<span class="string">'src/posts/*.md'</span>]
    }
  }
}</code></pre>
<p>And given we have defined a custom helper, <code>opt</code>, which gets properties from the <code>assemble.options</code> object and returns them:</p>
<pre><code class="language-js">module.exports.register = register = <span class="function"><span class="keyword">function</span><span class="params">(Handlebars, options)</span> {</span>

  Handlebars.registerHelper(<span class="string">'opt'</span>, <span class="function"><span class="keyword">function</span><span class="params">(key)</span> {</span>
    <span class="keyword">return</span> options[key] || <span class="string">''</span>;
  });

};</code></pre>
<p>We can now user our helper in a Handlebars template like this:</p>
<pre><code class="language-html">&lt;div&gt;Version: v{{opt &#39;version&#39;}}&lt;/div&gt;</code></pre>
<p>And the output would be:</p>
<pre><code class="language-html">&lt;div&gt;Version: v0.1.0&lt;/div&gt;</code></pre>
<h2 id="related-info">Related Info</h2>
<ul>
<li>[Helpers][]</li>
<li>[Options][]</li>
</ul>
<h2 id="options-layout">options.layout</h2>
<blockquote>
<p>Layouts are commonly used with client-side templates as a quick way to &quot;wrap&quot; a number of [pages][] with commonly used page &quot;sections&quot;, such as the head, footer or navigation.</p>
</blockquote>
<h2 id="defining-layouts">Defining Layouts</h2>
<p>Oftentimes you will need more than one layout for your project, so layouts can be defined using the <code>options.layout</code> variable at the task or target-level, or they can be specified at the page-level by adding a <code>layout</code> property to the [YFM][YAML front matter].</p>
<h2 id="the-body-tag">The <code>{{&gt; body }}</code> tag</h2>
<p>Although layouts are optional, the <code>{{&gt; body }}</code> tag is required for content to be pulled into a layout.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- the body tag is used to &quot;pull in&quot; content from pages --&gt;
    {{&gt; body }}
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="related-info">Related Info</h2>
<ul>
<li>Learn about [Layouts][]</li>
<li>Learn about [layoutdir][]</li>
</ul>
<h2 id="options-layoutdir">options.layoutdir</h2>
<blockquote>
<p>Path to the directory to be used as the &quot;cwd&quot; for layouts</p>
</blockquote>
<p><code>layoutdir</code> makes maintaining [layouts][options-layout] a little easier on projects that require more than one layout. The primary advantage of using the feature is that you can change or rename the directory where your layouts are stored without having to update the path to each layout used throughout your project. It could also reduce some clutter in the <a href="http://gruntjs.com">Gruntfile</a> and [YAML Front Matter][yaml-front-matter].</p>
<p>Additionally, a <code>layoutdir</code> can be defined for each [targets][targets], allowing for even greater control over how [layouts][] are used in your projects.</p>
<h2 id="usage-examples">Usage Examples</h2>
<h3 id="without-layoutdir-">Without <code>layoutdir</code></h3>
<p>When <code>layoutdir</code> <em>is not defined</em>, each layout must be defined using the <em>full path from the project root to the layout</em>:</p>
<pre><code>assemble: {
  options: {
    layout: &#39;src/templates/layouts/default-layout.hbs&#39;
  },
  docs: {
    options: {
      layout: &#39;src/templates/layouts/docs-layout.hbs&#39;
    },
    ...
  },
  blog: {
    options: {
      layout: &#39;src/templates/layouts/blog-layout.hbs&#39;
    },
    ...
  }
  // etc.
}</code></pre>
<p>This also applies to [YAML front matter][yaml-front-matter] when it is necessary to &quot;override&quot; layouts at the page-level:</p>
<pre><code class="language-html">---
title: Blog
layout: src/templates/layouts/blog-layout.hbs
---</code></pre>
<h3 id="with-layoutdir-">With <code>layoutdir</code></h3>
<p>When <code>layoutdir</code> is defined only require the name of the layout to be used (<em>must include the file extension</em>):</p>
<pre><code>assemble: {
  options: {
    layoutdir: &#39;src/templates/layouts&#39;,
    layout: &#39;default-layout.hbs&#39;
  },
  docs: {
    options: {
      layout: &#39;docs-layout.hbs&#39;
    },
    ...
  },
  blog: {
    options: {
      layout: &#39;blog-layout.hbs&#39;
    },
    ...
  }
  // etc.
}</code></pre>
<p>And in [YAML front matter][yaml-front-matter]:</p>
<pre><code class="language-html">---
title: Blog
layout: blog-layout.hbs
---</code></pre>
<h2 id="a-word-of-caution">A Word of Caution</h2>
<p>While <code>layoutdir</code> can make your project a little easier to manage, it is strongly recommended that you <strong>establish clear and consistent conventions for your layouts, and follow them</strong>. Otherwise, this feature might end up causing more problems than it solves. </p>
<p>Here are some recommendations.</p>
<ul>
<li>Use names such as <code>default-layout.hbs</code> versus simply <code>default.hbs</code>, and</li>
<li>Use a unique name for each layout used throughout a project. </li>
</ul>
<h3 id="why-clear-naming-conventions-are-important">Why clear naming conventions are important</h3>
<p>To understand why this is important, imagine that you&#39;re project has three &quot;sub-projects&quot;, or [targets][]: <code>components</code>, <code>docs</code> and <code>blog</code>, and that each target has a different layout. This is a fairly basic, common scenario. But remember that each may also have its own <code>layoutdir</code> as well, which creates potential for conventions that lead to using the wrong layout accidentally, such as this:</p>
<h4 id="dont-do-this">Dont&#39; do this</h4>
<pre><code>assemble: {
  components: {
    options: {
      layoutdir: &#39;src/components/layouts&#39;,
      layout: &#39;default.hbs&#39;
    }
    ...
  },
  docs: {
    options: {
      layoutdir: &#39;src/docs/layouts&#39;,
      layout: &#39;default.hbs&#39;
    }
    ...
  },
  blog: {
    options: {
      layoutdir: &#39;src/blog/layouts&#39;,
      layout: &#39;default.hbs&#39;
    }
    ...
  }
  // etc.
}</code></pre>
<p>Note that the layout name is the same for each target, but the <code>layoutdir</code> is a different directory, indicating that there are three different &quot;default&quot; layouts. </p>
<p>While it might make sense for each target to have its own <code>layoutdir</code>, since layouts can be overridden in the [YAML front matter][yaml-front-matter] of individual pages, it is not a good idea to use the same name for multiple layouts, <em>unless you are intentionally using this naming convention as a strategy</em>. The reason is that it gets very difficult to track which page is building from which layout when working inside the pages themselves.</p>
<h3 id="difficult-to-follow">Difficult to follow</h3>
<p>Without <code>layoutdir</code>, you have the entire path to follow, but without it you must rely on the name of the layout itself to guide you. </p>
<pre><code class="language-html">---
title: Any Page
layout: default.hbs
---</code></pre>
<h3 id="much-better">Much better</h3>
<p>Using a more descriptive name for the layout helps avoid confusion <em>now</em>:</p>
<pre><code class="language-html">---
title: Any Page
layout: blog-default.hbs
---</code></pre>
<p>Of course, these are only recommendations and you will need to find a strategy that works for you and your team. </p>
<h2 id="related-info">Related Info</h2>
<ul>
<li>[options.layout][options-layout]</li>
<li>[Layouts][]</li>
</ul>
<h2 id="registering-partials">Registering Partials</h2>
<p>Assemble automatically registers any partials supplied via the <code>partials</code> option at the task or target levels. </p>
<pre><code class="language-javascript">assemble {
  docs: {
    options: {
      partials: [<span class="string">'src/templates/partials/**/*.md'</span>]
    },
    files: {
      <span class="string">'docs/'</span>: [<span class="string">'src/templates/pages/*.md'</span>]
    }
  }
}</code></pre>
<h3 id="task-target-behavior">Task-target behavior</h3>
<p>Any partials registered at the <em>task</em> level are are also available at the <em>target</em> level. </p>
<p><strong>Important!</strong> It is standard in Grunt.js for target-level options to overwrite task-level options. However, assemble merges the list of partials defined at the task-level with the partials defined for each target. </p>
<h2 id="usage-examples">Usage examples</h2>
<h3 id="ways-to-apply-context-to-partials">Ways to apply context to partials</h3>
<h4 id="-inline-">&quot;Inline&quot;</h4>
<p>You can establish context inside the partials:</p>
<pre><code class="language-handlebars"><span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">primary</span>}}</span>
<span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">info</span>}}</span>
<span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">success</span>}}</span>
<span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">warning</span>}}</span>
<span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">danger</span>}}</span>
<span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">module.panel</span>-<span class="variable">query</span>}}</span></code></pre>
<h4 id="block-expressions">Block expressions</h4>
<p>Wrap partials in block expressions and either set the context on the partial:</p>
<pre><code class="language-handlebars"><span class="expression">{{<span class="begin-block">#module</span>}}</span>
  <span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">panel</span>-<span class="variable">inverse</span>}}</span>
  <span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">panel</span>-<span class="variable">success</span>}}</span>
  <span class="expression">{{&gt; <span class="variable">module</span> <span class="variable">panel</span>-<span class="variable">info</span>}}</span>
<span class="expression">{{<span class="end-block">/module</span>}}</span></code></pre>
<p>Or on the section tags:</p>
<pre><code class="language-handlebars"><span class="expression">{{<span class="begin-block">#module.panel</span>-<span class="variable">base</span>}}</span>
  <span class="expression">{{&gt; <span class="variable">module</span> }}</span>
<span class="expression">{{<span class="end-block">/module.panel</span>-<span class="variable">base</span>}}</span></code></pre>



<h1>Templates</h1>
<h2 id="built-in-helpers">Built-in Helpers</h2>
<p>Assemble includes <a href="http://github.com/assemble/helper-lib" title="Extensive collection of Handlebars helpers">helper-lib</a> as a dependency, so all of the helpers from that library are available by default. </p>
<p><a href="http://github.com/assemble/helper-lib" title="Extensive collection of Handlebars helpers">helper-lib</a> includes more than <strong>100 Handlebars helpers</strong> from that library in your templates. </p>
<h3 id="helpers-created-for-assemble">Helpers created for Assemble</h3>
<p>Most helpers from <a href="http://github.com/assemble/helper-lib" title="Extensive collection of Handlebars helpers">helper-lib</a> can be used with any Handlebars project, but a handful of helpers were created specifically for Assemble, including:</p>
<ul>
<li><strong>dirname</strong>: Returns the absolute path to the given file/directory. Would return: <code>path/to/variables.md</code>. Usage: <code>{{dirname [path]}}</code></li>
<li><strong>pagename</strong>: Returns the full-name of a given file. Would return: <code>variables.md</code>. Usage: <code>{{filename &quot;docs/toc.md&quot;}}</code></li>
<li><strong>filename</strong>: Can be used as an alternate for <code>pagename</code>. </li>
<li><strong>basename</strong>: Returns the basename of a given file. Would return: <code>variables</code> Usage: <code>{{base &quot;docs/toc.md&quot;}}</code></li>
<li><strong>extension</strong>: Returns the extension of a given file. Would return: <code>.md</code> Usage: <code>{{extension &quot;docs/toc.md&quot;}}</code></li>
<li><strong>ext</strong>: Can be used as an alternate for<code>extension</code>. </li>
<li><strong>relative</strong>: Returns the derived relative path from file A to file B. Usage: <code>{{relative [from] [to]}}</code>. This can also be used with <code>page</code> and <code>pages</code>.</li>
<li><strong>markdown</strong>: Markdown block helper enables writing markdown inside HTML and then renders the markdown as HTML inline with the rest of the page. Usage: <code>{{#markdown}}{{/markdown}}</code></li>
<li><strong>md</strong>: Markdown helper used to read in a file and inject the rendered markdown into the HTML. Usage: <code>{{md [path]}}</code></li>
<li><strong>embed</strong>: Embeds code from an external file as preformatted text. The first parameter requires a path to the file you want to embed. The second optional parameter allows forcing syntax highlighting for a specific language. Usage: <code>{{embed &#39;path/to/file.js&#39;}}</code> or <code>{{embed &#39;path/to/file.hbs&#39; &#39;html&#39;}}</code></li>
<li><strong>jsFiddle</strong>: Embed a jsFiddle, second parameter sets the desired tabs. Usage: <code>{{jsfiddle [id] [tabs]}}</code></li>
<li><strong>gist</strong>: Downloads and embeds public GitHub Gists by adding only the Id of the Gist. Usage: <code>{{gist [id] [file]}}</code></li>
<li><strong>authors</strong>: Reads in data from an &quot;AUTHORS&quot; file to generate markdown formatted author or list of authors for a README.md. Accepts a second optional parameter to a different file than the default. Usage: <code>{{authors}}</code> or <code>{{ authors [file] }}</code></li>
<li><strong>changelog</strong>: Reads in data from an &quot;CHANGELOG&quot; file to generate markdown formatted changelog or list of changelog entries for a README.md. Accepts a second optional parameter to change to a different file than the default. Usage: <code>{{changelog [src]}}</code></li>
<li><strong>roadmap</strong>: Reads in data from an &quot;ROADMAP&quot; file to generate markdown formatted roadmap or list of roadmap entries for a README.md. Accepts a second optional parameter to change to a different file than the default. Usage: <code>{{roadmap [src]}}</code></li>
</ul>
<p>Many additional helpers are available in the following categories:</p>
<ul>
<li><code>assemble</code></li>
<li><code>collections</code></li>
<li><code>comparisons</code></li>
<li><code>dates</code></li>
<li><code>file</code></li>
<li><code>html</code></li>
<li><code>inflections</code></li>
<li><code>logging</code></li>
<li><code>markdown</code></li>
<li><code>math</code></li>
<li><code>miscellaneous</code></li>
<li><code>numbers</code></li>
<li><code>objects</code></li>
<li><code>path</code></li>
<li><code>special</code></li>
<li><code>strings</code></li>
<li><code>url</code></li>
</ul>
<p>Visit <a href="http://github.com/assemble/helper-lib" title="Extensive collection of Handlebars helpers">helper-lib</a> to learn more.</p>
<h2 id="related-info">Related info</h2>
<ul>
<li>[Templates][templates]</li>
<li>[helper-lib Github repo][]</li>
<li>[handlebarsjs.com][handlebars]</li>
</ul>
<blockquote>
<p>Layouts are used for &quot;wrapping&quot; the content of individual pages with common HTNL, such as a &quot;header&quot; and &quot;footer&quot;. </p>
</blockquote>
<h2 id="layout-example">Layout example</h2>
<p>Layouts are optional, but the <code>{{&gt; body }}</code> tag is required for content to be pulled into a layout.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- the body tag is used to &quot;pull in&quot; content from pages --&gt;
    {{&gt; body }}
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="granular-control">Granular control</h2>
<ol>
<li><strong>Task options</strong>: Great for defining a &quot;project-wide&quot; default. </li>
<li><strong>Target options</strong>: Override the &quot;project default&quot; in the <code>options</code> for each target. Offers greater control over which &quot;types&quot; of pages get which <code>layout</code>. </li>
<li><strong>Page-by-page</strong>: If you require more granularity you can define a layout in the [YFM][yaml-front-matter] of a page</li>
</ol>
<h3 id="multiple-layouts">Multiple layouts</h3>
<p>Since you can create as many [targets][] as you require, defining layouts in the Gruntfile is a great way of quickly setting up your layout &quot;defaults&quot;. In the <code>assemble</code> task in your Gruntfile.js, you can define a layout at the task-level, and/or a different layout for each build target:</p>
<pre><code class="language-javscript">assemble: {
  options: {
    layout: &#39;layouts/default.hbs&#39;
  },
  site: {
    files: {
      &#39;site/&#39;: [&#39;templates/pages/*.hbs&#39;]
    }
  },
  blog: {
    options: {
      layout: &#39;layout/post.hbs&#39;
    },
    files: {
      &#39;blog/&#39;: [&#39;templates/posts/*.hbs&#39;]
    }
  },
  docs: {
    options: {
      layout: &#39;layouts/docs.hbs&#39;
    },
    files: {
      &#39;docs/&#39;: [&#39;templates/docs/*.hbs&#39;]
    }
  }
}</code></pre>
<h2 id="page-specific-layouts">Page-specific Layouts</h2>
<p>If you require a higher level of granularity than defining layouts in the Gruntfile, you may also define layouts on a page-by-page basis, thus overriding both the task-level (&quot;global&quot;) defaults and the target-level defaults.</p>
<p>To do so, just add the layout to the [YFM][yaml-front-matter] of the page like this:</p>
<pre><code class="language-yaml">---
layout: path/to/layout.hbs
---</code></pre>
<h2 id="disabling-layouts">Disabling Layouts</h2>
<ul>
<li><strong>Pages</strong>: add <code>layout: false</code> to the YAML front matter of any page that should build without a layout. </li>
<li><strong>Targets</strong>: add <code>layout: false</code> to the options of any target that should build pages without a layout. </li>
</ul>
<h2 id="example-usage">Example usage</h2>
<p>Your imagination is the only limit to what can be done with layouts, so these are just examples.</p>
<h3 id="basic-layout">Basic layout</h3>
<p>This is something you might use to wrap basic pages for a demo, documentation, etc.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header class=&quot;page-header&quot;&gt;
      &lt;h1&gt;{{title}} &lt;/h1&gt;
      &lt;p class=&quot;lead&quot;&gt;{{description}}&lt;/p&gt;
    &lt;/header&gt;
    &lt;!-- the body tag is required to pull in content from pages --&gt;
    {{&gt; body }}
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="advanced-layout">Advanced layout</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{page.title}} &amp;middot; {{ site.title }}&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
    {{&gt; head-extras }}
    &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;site.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body class=&quot;{{ page.modifier }}&quot; id=&quot;{{ page.id }}&quot;&gt;

    &lt;!-- HEADER --&gt;
    &lt;header id=&quot;header&quot;&gt;

      &lt;!-- SITE TITLE OR LOGO --&gt;
      {{#section main-header}}
      &lt;h1 data-content-field=&quot;site-title&quot;&gt;
        &lt;a href=&quot;/&quot;&gt;
          {{#if site.logo}}
          &lt;img src=&quot;{{ assets }}/img/{{ site.logo }}&quot; alt=&quot;{{ site.title }}&quot;&gt;
          {{else}}
          {{ site.title }}
          {{/if}}
        &lt;/a&gt;
      &lt;/h1&gt;
      {{/section}}

      &lt;!-- SITE TAGLINE --&gt;
      {{#section tagline}}
      &lt;p&gt;{{.}}&lt;/p&gt;
      {{/section}}

      &lt;!-- MAIN NAVIGATION --&gt;
      {{&gt; main-navigation }}
    &lt;/header&gt;

    &lt;!-- CONTENT --&gt;
    &lt;section id=&quot;content&quot;&gt;
      {{&gt; body }}
    &lt;/section&gt;

    &lt;!-- FOOTER --&gt;
    &lt;footer id=&quot;footer&quot;&gt;
      {{&gt; footer }}
    &lt;/footer&gt;

  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="markdown-layout">Markdown layout</h3>
<p>Layouts don&#39;t have to be HTML, they can be whatever language you want them to be. If you&#39;re generating markdown pages instead of HTML, maybe for a project wiki or other markdown documentation, then you&#39;ll want to use a markdown formatted <code>layout</code>. </p>
<p>In this example, instead of adding adding the traditional head and footer we&#39;ll add some link references to make sure the same ones are used on every generated page. This makes it easier to maintain links and it also cuts down on potential for broken links:</p>
<pre><code class="language-markdown">{{&gt; body }}

<span class="horizontal_rule">---</span>

<span class="emphasis">_This page was generated using Grunt and [assemble][repo] on {{ today }}._</span>

[org]: https://github.com/assemble
[repo]: https://github.com/assemble/assemble
[issues]: https://github.com/assemble/assemble/issues
[wiki]: https://github.com/assemble/assemble/wiki</code></pre>
<h2 id="layout-faq">Layout FAQ</h2>
<ul>
<li>Layouts are optional</li>
<li>When a layout is specified, <em>it must include a <code>{{&gt; body }}</code> tag to render content</em> from any file that uses the layout. </li>
<li>Layouts may be defined in the Gruntfile or in [YFM][yaml-front-matter] of a page. </li>
<li>A layout defined for a target will override a layout defined at the task level.</li>
<li>A layout defined in [YFM][yaml-front-matter] will override a layout defined in the Gruntfile</li>
<li>[Lo-dash templates][templates] can be used in YAML front-matter ayout. Path, file name and extension can be determined</li>
</ul>
<h2 id="related-info">Related info</h2>
<ul>
<li>[options.layout][options-layout]</li>
<li>[Pages][pages]</li>
<li>[Partials][partials]</li>
<li>[Templates][templates]</li>
<li>[YFM][yaml-front-matter]</li>
</ul>
<blockquote>
<p>Partials are reusable fragments of code that can be included in a page and rendered </p>
</blockquote>
<h2 id="syntax">Syntax</h2>
<p>Partials are useful when you have blocks of reusable code that is applicable in different contexts. The <code>Handlebars.registerPartial</code> method, which registers a partial, accepts the name of the partial as its first argument and either a <em>template source string</em> or a <em>compiled template</em> as its second argument. </p>
<p>Accepting a compiled template as the second argument enables you, for example, to use the partial in a loop that outputs a list but also append items to the list later using the partial’s template function.</p>
<p>To use a partial from a template, simply include <code>{{&gt; partial-name }}</code>. For example:</p>



<h1>Data</h1>
<blockquote>
<p>Mix and match JSON, YAML, YAML front matter, and data stored in the Gruntfile however you want.</p>
</blockquote>
<p>Table of Contents</p>
<ul>
<li>Data Formats</li>
<li>The &quot;data&quot; Object</li>
</ul>
<h2 id="data-formats">Data Formats</h2>
<p>Any of the following data formats may be used:</p>
<ul>
<li>[JSON][json] files, such as <code>my-data.json</code></li>
<li>[YAML][yaml] files, such as <code>my-data.yml</code></li>
<li>[YAML Front-Matter][yfm], embedded directly inside the page/template itself</li>
</ul>
<p>Visit the [options.data][options-data] page to learn about supplying data to your templates. </p>
<h2 id="usage-examples">Usage examples</h2>
<p>Let&#39;s start by creating a template, which can be any kind of markdown, text, xml or markup/HTML that we want to use. For this example our template is going to be HTML, and since I&#39;m feeling creative let&#39;s call it <code>my-template.hbs</code>. </p>
<p>Now, focusing only on the <code>head</code> of our HTML document, let&#39;s add template variables for <code>title</code> and <code>author</code> so that we can later replace them with real data:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
    &lt;meta name=&quot;author&quot; content=&quot;{{author}}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Handlebars.js is the default template engine in Assemble, so our variables are wrapped in &quot;Handlebars expressions&quot;: <code>{{</code> and <code>}}</code>. </p>
<h3 id="json-example">JSON example</h3>
<p>Here is an example of what we might put inside of <code>my-template.json</code> to populate our template with data.</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"Assemble"</span></span>,
  "<span class="attribute">author</span>": <span class="value"><span class="string">"Brian Woodward"</span>
</span>}</code></pre>
<h3 id="yaml-example">YAML example</h3>
<p>Here is the same in YAML format: <code>my-template.yml</code></p>
<pre><code class="language-yaml">title: Assemble
author: Brian Woodward</code></pre>
<p>And this template: </p>
<p><code>my-template.hbs</code></p>
<pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;</code></pre>
<h3 id="yaml-front-matter-example">YAML front-matter example</h3>
<p>Or, in cases where we only require simple metadata we can use YAML Front-matter to eliminate the need for an external data file:</p>
<pre><code class="language-yaml">---
title: Assemble
author: Brian Woodward
---

&lt;h1&gt;{{ title }}&lt;/h1&gt;</code></pre>
<p>Outputs:</p>
<pre><code class="language-html">&lt;h1&gt;Assemble&lt;/h1&gt;
&lt;p&gt;Brian Woodward&lt;/p&gt;</code></pre>
<h3 id="underscore-and-yaml-front-matter">Underscore and yaml front-matter</h3>
<p>Furthermore, we can optionally use underscore templates in the YAML front-matter to translate external variables into data inside the content:</p>
<pre><code class="language-yaml">---
title: &lt;%= some.title.variable %&gt;
author: &lt;%= some.author.variable %&gt;
---

&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;{{ author }}&lt;/p&gt;</code></pre>
<h2 id="the-data-object">The &quot;data&quot; Object</h2>
<p>Using <code>data.json</code> or <code>data.yml</code> should work, but works a little bit differently than if you put data into a file called <code>myData.json</code>. When the data is in <code>data.json</code>, it&#39;s loaded directly into the root of the context...</p>
<p><code>data.json</code>:</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"My Title"</span>
</span>}</code></pre>
<p><code>myTemplate.hbs</code>:</p>
<pre><code class="language-handlebars">Data</code></pre>
<p>When used in <code>myData.json</code>, the data can be accessed through the name of the file...</p>
<p><code>myData.json</code>:</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"My Title"</span>
</span>}</code></pre>
<p><code>myTemplate.hbs</code>:</p>
<pre><code class="language-handlebars">
</code></pre>
<h2 id="related-information-">Related information:</h2>
<ul>
<li>[options.data][options-data]</li>
<li>[Complete list of Options][Options]</li>
<li>[Context][]</li>
<li>[Templates][]</li>
<li>[Variables][built-in-variables]</li>
</ul>

<blockquote>
<p>In Assemble, context is the current JSON data object that templates can use.</p>
</blockquote>
<p>If you are unfamiliar with how Handlebar templates work, please visit the <a href="http://handlebarsjs.com/">Handlebar documentation</a> for more information. Also see Assemble&#39;s wiki page for <a href="https://github.com/assemble/assemble/wiki/Templates">Templates</a> and [Data][].</p>
<h2 id="context-in-handlebars">Context in Handlebars</h2>
<p>In Handlebars, every template has a context. Blocks such as {{#if}} create &quot;inline&quot; templates, and the &quot;if&quot; helper then determines in which context to render the template.</p>
<p>Some helpers, like {{#if}}, preserve the current context, while others such as {{#each}} and {{#with}} <em>change the context</em> in different ways. <em>Helpers can even change the context to something totally new if they want</em>:</p>
<pre><code>options.fn({ 
  published: true 
})</code></pre>
<p>Handlebars also supports nested contexts, making it possible to look up properties nested below the current context. Nested handlebars paths can also include <code>../</code> segments, which evaluate their paths against a parent context. </p>
<p>The <code>..</code> feature means &quot;look this up on the context of the parent template&quot;. In some cases, that will amount to the parent in the current object (with). In other cases, it will not. In cases like if, which preserve the context, .. will happen to point to the same object, but this is just a coincidence. In all cases, <code>..</code> is lexically bound to the parent template.</p>
<h2 id="the-context-object">The &quot;context&quot; object</h2>
<p>The context object is just a [JSON data][JSON] object that when passed to the compiled template function becomes the value of this inside your template. You must use the name of the associated [data file][Data] to access properties and call helper methods on the context object. </p>
<h3 id="example">Example</h3>
<p>Given we have a data file <code>alert.json</code> that contains the following properties:</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"Heads up!"</span>
</span>}</code></pre>
<p>In our template <code>alert.hbs</code>, we will now look up the properites of <code>alert.json</code> by using the name of the file, <code>alert</code>, as the current context. So to retrieve the <code>title</code> property, we would do this:</p>
<pre><code class="language-handlebars"><span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="expression">{{<span class="variable">alert.title</span>}}</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></code></pre>
<p>Which renders to:</p>
<pre><code class="language-html">&lt;h1&gt;Heads up!&lt;/h1&gt;</code></pre>
<h2 id="root-context">Root context</h2>
<p>In Assemble, the root of the context is where the data object starts. Everything under the root is a child property. Also, when a variable is at &quot;the root of the context&quot; the variable may be used as-is, or &quot;raw&quot;, enabling you to look up properties <em>for the &quot;current&quot; object</em> without nesting the context <em>within</em> the current object. In other words, the &quot;path&quot; of the current object does not need to be appended to the variable, so instead of <code>about_us.title</code>, you may simply use <code>title</code>. </p>
<h3 id="example">Example</h3>
<p>In <code>layout.hbs</code> we will use <code>{{title}}</code> to lookup the <code>title</code> property on each page that is passed into the layout.  </p>
<pre><code class="language-handlebars"><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="expression">{{<span class="variable">title</span>}}</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="expression">{{&gt; <span class="variable">body</span> }}</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></code></pre>
<h2 id="the-data-object">The &quot;data&quot; object</h2>
<p>When data is added directly to a file named <code>data.json</code> (or <code>data.yml</code>) it will be loaded <em>directly into the root of the context</em> by Assemble. Note that your templates will need to be namespaced differently than if you put data into a file called <code>myData.json</code>. </p>
<p>For example, given we have a file named <code>data.json</code> with:</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"My Title"</span>
</span>}</code></pre>
<p>Inside <code>myTemplate.hbs</code>, we would use:</p>
<pre><code class="language-handlebars"><span class="expression">{{<span class="variable">title</span>}}</span></code></pre>
<p>However, using the same example but with a file named <code>myData.json</code>, the data must now be accessed using the name of the file. </p>
<p>So, given we have <code>myData.json</code> with:</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"My Title"</span>
</span>}</code></pre>
<p>Out template, <code>myTemplate.hbs</code>, would have:</p>
<pre><code class="language-handlebars"><span class="expression">{{<span class="variable">myData.title</span>}}</span></code></pre>
<h2 id="-this-expression">&quot;this&quot; expression</h2>
<p>You can use the <code>this</code> expression in any context to refer to the current context. </p>
<p>For example (from <a href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>), inside the <code>{{#each}}</code> block, you can use <code>this</code> to reference the element being iterated over.</p>
<pre><code class="language-handlebars"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"people-list"</span>&gt;</span>

<span class="tag">&lt;/<span class="title">ul</span>&gt;</span></code></pre>
<p>when used with this context, <code>people.json</code>:</p>
<pre><code class="language-json">[
  <span class="string">"Jon Schlinkert"</span>,
  <span class="string">"Brian Woodward"</span>
]</code></pre>
<p>will result in:</p>
<pre><code class="language-html">&lt;ul class=&quot;people-list&quot;&gt;
  &lt;li&gt;Jon Schlinkert&lt;/li&gt;
  &lt;li&gt;Brian Woodward&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<blockquote>
<p>Mix and match JSON, YAML, YAML front matter, and data stored in the Gruntfile however you want.</p>
</blockquote>
<h2 id="accepted-data-types">Accepted data types</h2>
<p>Any of the following data formats may be used:</p>
<ul>
<li>[JSON][json] files, such as <code>my-data.json</code></li>
<li>[YAML][yaml] files, such as <code>my-data.yml</code></li>
<li>[YAML Front-Matter][yfm], embedded directly inside the page/template itself</li>
</ul>
<p>Visit the [options.data][options-data] page to learn about supplying data to your templates. </p>
<h2 id="usage-examples">Usage examples</h2>
<p>Let&#39;s start by creating a template, which can be any kind of markdown, text, xml or markup/HTML that we want to use. For this example our template is going to be HTML, and since I&#39;m feeling creative let&#39;s call it <code>my-template.hbs</code>. </p>
<p>Now, focusing only on the <code>head</code> of our HTML document, let&#39;s add template variables for <code>title</code> and <code>author</code> so that we can later replace them with real data:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;title&gt;{{title}}&lt;/title&gt;
    &lt;meta name=&quot;author&quot; content=&quot;{{author}}&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Handlebars.js is the default template engine in Assemble, so our variables are wrapped in &quot;Handlebars expressions&quot;: <code>{{</code> and <code>}}</code>. </p>
<h3 id="json-example">JSON example</h3>
<p>Here is an example of what we might put inside of <code>my-template.json</code> to populate our template with data.</p>
<pre><code class="language-json">{
  "<span class="attribute">title</span>": <span class="value"><span class="string">"Assemble"</span></span>,
  "<span class="attribute">author</span>": <span class="value"><span class="string">"Brian Woodward"</span>
</span>}</code></pre>
<h3 id="yaml-example">YAML example</h3>
<p>Here is the same in YAML format: <code>my-template.yml</code></p>
<pre><code class="language-yaml">title: Assemble
author: Brian Woodward</code></pre>
<p>And this template: </p>
<p><code>my-template.hbs</code></p>
<pre><code>&lt;h1&gt;{{ title }}&lt;/h1&gt;</code></pre>
<h3 id="yaml-front-matter-example">YAML front-matter example</h3>
<p>Or, in cases where we only require simple metadata we can use YAML Front-matter to eliminate the need for an external data file:</p>
<pre><code class="language-yaml">---
title: Assemble
author: Brian Woodward
---

&lt;h1&gt;{{ title }}&lt;/h1&gt;</code></pre>
<p>Outputs:</p>
<pre><code class="language-html">&lt;h1&gt;Assemble&lt;/h1&gt;
&lt;p&gt;Brian Woodward&lt;/p&gt;</code></pre>
<h3 id="underscore-and-yaml-front-matter">Underscore and yaml front-matter</h3>
<p>Furthermore, we can optionally use underscore templates in the YAML front-matter to translate external variables into data inside the content:</p>
<pre><code class="language-yaml">---
title: &lt;%= some.title.variable %&gt;
author: &lt;%= some.author.variable %&gt;
---

&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;{{ author }}&lt;/p&gt;</code></pre>
<h2 id="faq">FAQ</h2>
<ul>
<li>Assemble merges task and target level data supplied from <code>options.data</code>. </li>
</ul>
<h2 id="related-info">Related Info</h2>
<ul>
<li>[Complete list of Options][Options]</li>
<li>[options.data][options-data]</li>
<li>[Variables][built-in-variables]</li>
</ul>
<blockquote>
<p>YFM is an <strong>optional</strong> section of valid YAML that is placed at the top of a page and is used for maintaining metadata for the page and its contents. </p>
</blockquote>
<p><strong>Actually</strong>, YFM can be used with both [pages][pages] and [partials][partials], so <em>unless otherwise noted</em> you can safely assume that when the documentation YFM of a page, the same applies for YFM of a partial. </p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li>YFM in &quot;pages&quot; (a &quot;page&quot; is any file specified in the <code>src</code> property of a task or target)</li>
<li>YFM in partials</li>
<li>Metadata</li>
<li>Content</li>
<li>Config data</li>
<li>Lo-Dash templates in YFM</li>
</ul>
<p>TOPICS TO COVER</p>
<ul>
<li>structured data for the file and/or its contents</li>
<li>supply metadata</li>
<li>define configuration settings, options </li>
<li>specify variables, built-in or custom</li>
<li>use lo-dash templates to bring the power of JavaScript to your YFM</li>
</ul>
<p>Use cases:</p>
<ul>
<li>collections</li>
<li>permalinks</li>
<li>lo-dash templates: time, date, metadata &quot;pipeline&quot;</li>
</ul>
<h2 id="yfm-variables-">YFM &quot;Variables&quot;</h2>
<h3 id="built-in-variables">Built-in Variables</h3>
<ul>
<li><code>layout</code> : Optionally define or override the layout to use. You must include file extension, since Assemble can process multiple file types. Layout files can exist in any directory, and may be.</li>
<li><code>published</code> : set to <code>false</code> to exclude a file from being rendered by a task-target.</li>
<li><code>category</code>/<code>categories</code>/<code>tags</code> : Define the categories and tags as <a href="http://en.wikipedia.org/wiki/YAML#Lists or a space-separated string">YAML lists</a> or a space-separated string. for each category and tag, Assemble will generate a page in the <code>dest</code> directory.</li>
</ul>
<p>If set, allows to specify tags attributed to given entry. Tag pages are generated automatically. Entry may belong to more than one tag, use YAML List to specify multiple tags.</p>
<h3 id="custom-variables">Custom Variables</h3>
<p>Any variables in the front-matter that are not predefined are mixed into the data that is sent to the Liquid templating engine during the conversion. For instance, if you set a title, you can use that in your layout to set the page title:</p>
<pre><code class="language-html">&lt;title&gt;{{ page.title }}&lt;/title&gt;</code></pre>
<h2 id="using-lo-dash-templates-in-yfm">Using Lo-Dash templates in YFM</h2>
<h3 id="metadata-conduit-">Metadata &quot;conduit&quot;</h3>
<p>This may not be obvious at first, is that YAML Front-Matter acts as a kind of &quot;conduit&quot; for passing information to pages via Lo-Dash templates. </p>
<p>So you could do this:</p>
<pre><code class="language-js">grunt.initConfig({
  assemble: {
    component: {
      options: {
        data: <span class="string">'page.json'</span>
      },
      files: {
        <span class="string">'index.html'</span>: [<span class="string">'src/pages/*.hbs'</span>]
      }
    }
  }
});</code></pre>
<p>With <code>page.json</code> containing:</p>
<pre><code class="language-json">{
  "<span class="attribute">index</span>": <span class="value">{
    "<span class="attribute">title</span>": <span class="value"><span class="string">"Home"</span>
  </span>}</span>,
  "<span class="attribute">about</span>": <span class="value">{
    "<span class="attribute">title</span>": <span class="value"><span class="string">"About Us"</span>
  </span>}
</span>}</code></pre>
<p>And the <a href="">YAML Front-Matter</a> of the page, use underscore templates:</p>
<pre><code class="language-yaml">---
title: &lt;%= page.index.title %&gt;
---

YAML front matter</code></pre>
<p>Alternatively, inside the Grunfile you can use <code>grunt.config.set</code> to define the data to be used for a given variable: </p>
<pre><code class="language-js">grunt.config.set(<span class="string">'page.index.title'</span>, <span class="string">'Home'</span>);</code></pre>
<h3 id="example-usage">Example usage</h3>
<pre><code class="language-html">---
title: 
list: &lt;% _.forEach(people, function(name) { %&gt;&lt;li&gt;&lt;%= name %&gt;&lt;/li&gt;&lt;% }); %&gt;
people:
- Jon Schlinkert
- Brian Woodward
---
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;YAML front matter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;section class=&quot;people&quot;&gt;
      &lt;ul&gt;

      &lt;/ul&gt;
    &lt;/section&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<pre><code class="language-yaml">---
layout: default.hbs
title: Early humans discovered...
description: Lots of things, because they were early humans. 
date: 2013-07-04
categories:
- anthropology
- unibrows
- various wooly animals
tags:
- rocks
- wheel
- 30 inch wooden rims
published: false 
---</code></pre>
<pre><code class="language-html">--- 
title: My Blog
description: Like I said, my bloggg!
example:
  custom:
    variables:
    - one
    - two
    - three
---
&lt;div class=&quot;page-header&quot;&gt;
  &lt;h1&gt;YAML front matter&lt;/h1&gt;
  &lt;p class=&quot;lead&quot;&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;

&lt;/ul&gt;</code></pre>
<h2 id="yaml-front-matter-in-partials">YAML Front-Matter in Partials</h2>
<pre><code class="language-html">---
title: &lt;%= component.name ][ pkg.name %
require: [&lt;%= title %&gt;.css, &lt;%= title %&gt;.js]
---
&lt;!-- {{title}} --&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;span3&quot;&gt;
    &lt;div class=&quot;dropdown&quot;&gt;
      &lt;div&gt;User Settings&lt;/div&gt;
      &lt;ul class=&quot;dropdown-menu&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;My Profile&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Friend Requests&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Account Settings&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Log Out&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;&lt;!-- /{{title}} --&gt;</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;{{ titleize component }} Component&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{assets}}/css/{{component}}.css&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      {{&gt; body }}
    &lt;/div&gt;
    &lt;script src=&quot;{{assets}}/js/{{component}}.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="rendering-lists">Rendering Lists</h3>
<p>Use <a href="http://en.wikipedia.org/wiki/YAML#Associative_arrays_of_lists">YAML Associative Arrays</a> for rendering lists of information.</p>
<p>Indented Blocks, common in YAML data files, use indentation and new lines to separate the <code>key: value</code> pairs</p>
<pre><code class="language-yaml">---
title: Associative arrays
people:
  name: John Smith
  age: 33</code></pre>
<p>Inline Blocks, common in YAML data streams, use comma+space to separate the <code>key: value</code> pairs between braces:</p>
<pre><code class="language-yaml">morePeople:  {name: Grace Jones, age: 21}
---</code></pre>
<p>Used like this:</p>
<pre><code class="language-html">&lt;div class=&quot;page-header&quot;&gt;
  &lt;h1&gt;{{{title}}}&lt;/h1&gt; 
&lt;/div&gt;

&lt;div class=&quot;examples&quot;&gt;
  &lt;h4&gt;Associative arrays&lt;/h4&gt;
  &lt;dl class=&quot;dl-horizontal&quot;&gt;
    {{#people}}
      &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;{{name}}&lt;/dd&gt;
      &lt;dt&gt;Age:&lt;/dt&gt;  &lt;dd&gt;{{age}}&lt;/dd&gt;
    {{/people}}
    {{#morePeople}}
      &lt;dt&gt;Name:&lt;/dt&gt; &lt;dd&gt;{{name}}&lt;/dd&gt;
      &lt;dt&gt;Age:&lt;/dt&gt;  &lt;dd&gt;{{age}}&lt;/dd&gt;
    {{/morePeople}}
  &lt;/dl&gt;
&lt;/div&gt;</code></pre>
<h3 id="-more-examples-https-assemble-assemble-test-actual-yaml-"><a href="https://assemble/assemble/test/actual/yaml">More examples</a></h3>
<p>See some great usage examples in assemble&#39;s <a href="https://assemble/assemble/test/actual/yaml">YAML test files</a>:</p>
<ul>
<li>YAML associative arrays</li>
<li>YAML block literals</li>
<li>YAML comments</li>
<li>YAML data files</li>
<li>YAML data types</li>
<li>YAML documents</li>
<li>YAML lists</li>
<li>YAML relational-trees</li>
<li>YAML variables</li>
</ul>
<p><strong>Please note</strong>: <em>YFM cannot be parsed if it is not the first thing on the page</em>.</p>
<p><a href="https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter">YAML Front-Matter</a> was made popular by Jekyll, the &quot;blog-aware, static site generator&quot; that powers GitHub Pages.</p>
<ul>
<li>YAML front-matter is <strong>optionally</strong> used at the beginning of a page to define metadata for the page&#39;s content. </li>
<li>In order for YAML front-matter to be processed, it <em>must be the first thing at the top of the page</em>, and </li>
<li>To be valid, it must be &quot;wrapped&quot; with three leading dashes (above) (<code>---</code>) and three dashes following (below) (<code>---</code>).</li>
</ul>
<p>Example:</p>
<pre><code class="language-html">---
title: YAML front-matter
description: A very simple way to add structured data to a page.
---

&quot;Front matter is essentially metadata about the document its attached to, formatted in such a way that it does not get in the way. In other words, if you don&#39;t know its “Front Matter”, you probably wouldn&#39;t wonder what it is, or what its doing there.&quot;



&lt;h1&gt; {{ title }} &lt;/h1&gt;
&lt;p&gt;Page content here... {{ eieio }}&lt;/p&gt;</code></pre>
<h2 id="faq">FAQ</h2>
<ul>
<li>With <a href="https://github.com/assemble/assemble">Assemble</a> you may do <a href="https://github.com/assemble/assemble/tree/master/test/YAML">just about anything</a> with YAML front matter that you can do with <a href="http://www.yaml.org/spec/1.2/spec.html">valid YAML</a></li>
<li>YFM must be <a href="http://www.yaml.org/spec/1.2/spec.html">valid YAML</a> </li>
<li>YFM cannot be parsed if it is not the first thing on the page</li>
<li><a href="https://github.com/assemble/assemble">Assemble</a> parses YAML front matter into an object literal.</li>
<li>YFM allows you to define variables for a page, directly inside the page.</li>
</ul>
<p><strong>Custom Variables</strong></p>
<ul>
<li>You may use any of the default variables provided by Assemble, or you may define your own custom variables inside the YFM of a file.</li>
<li>You may add as many custom variables as you require</li>
</ul>
<p><strong>Lo-Dash Templates</strong></p>
<ul>
<li>You may use underscore [Lo-Dash templates][lodash] in YFM</li>
<li>Assemble exposes all variables defined in YAML front-matter to the page in which they were defined, thus...</li>
<li>Using [Lo-Dash templates][lodash] in YFM enables programmatic access to those pages across your project.</li>
<li>YFM may be used in any file that Assemble processes through any of the [src-dest or files mappings formats][files] available in Grunt.js. </li>
</ul>
<h3 id="recommended-usage">Recommended usage</h3>
<ul>
<li>YFM is best used for structured data, like configuration settings or metadata for a page, as opposed to long-form content.</li>
<li>YFM offers an easy way to maintain metadata or rendered data for pages and partials, as an <em>optional</em> alternative to using &quot;external&quot; <code>.json</code> or <code>.yaml</code> data files</li>
</ul>
<h3 id="not-recommended">Not recommended</h3>
<ul>
<li>YFM isn&#39;t the best option for long-form content or extensive amounts of metadata. In these cases you might want to consider externalizing your data to [JSON][] or [YAML][] files instead.</li>
</ul>
<h2 id="related-info">Related info</h2>
<ul>
<li>[YAML data][YAML]</li>
<li>[JSON data][JSON]</li>
</ul>
<h2 id="external-links">External links</h2>
<ul>
<li><a href="http://nodeca.github.io/js-yaml/">js-yaml &quot;online&quot;</a> allows you to play with YAML in the browser.</li>
<li><a href="http://www.yaml.org/spec/1.2/spec.html">YAML specification</a> </li>
<li><a href="http://www.yaml.org/"><a href="http://www.yaml.org/">http://www.yaml.org/</a></a></li>
<li><a href="http://en.wikipedia.org/wiki/YAML">wikipedia page about YAML</a> </li>
</ul>
<blockquote>
<p>YAML is a &quot;human-readable data serialization format&quot; that may be used with Assemble as an alternative to JSON</p>
</blockquote>
<p>As a data format, YAML may be used as an alternative to JSON.</p>
<h2 id="-yaml-front-matter-yaml-front-matter-">[YAML front matter][yaml-front-matter]</h2>
<blockquote>
<p>YAML front matter was made popular by Jekyll, the &quot;blog-aware, static site generator&quot; that powers GitHub Pages.</p>
</blockquote>
<p>YAML front-matter is optionally used at the beginning of a page to define metadata for the page&#39;s content. In order for YAML front-matter to be processed, it <em>must be the first thing at the top of the page</em>, and it must be &quot;wrapped&quot; properly using three dashes above (<code>---</code>) and three below (<code>---</code>).</p>
<p><strong>More information</strong></p>
<ul>
<li>Visit <a href="http://www.yaml.org/"><a href="http://www.yaml.org/">http://www.yaml.org/</a></a></li>
<li>Go to assemble&#39;s wiki page on [YAML front matter][] </li>
<li>See some great usage examples in assemble&#39;s <a href="https://assemble/assemble/test/actual/yaml">YAML test files</a>:</li>
</ul>


      </div>
    </div>
    
    <script src="assets/highlight.js"></script>
  </body>
</html>